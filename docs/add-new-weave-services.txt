HOW TO ADD NEW DATA TYPES TO WEAVE SYNCHRONIZATION

(For a working example of everything described in the file, see the changesets in which I added cookie-sync support.  The code was committed mostly in revision 283, and was then debugged over the course of revisions 285-286, 288-290, and 296-297.)


To weave/modules/engines.js, add a new subclass of Engine.  This is pretty simple: it just needs name(), logName(), and serverPrefix() methods that return strings; an attribute _core which is a SyncCore subclass object; and an attribute _store which is a Store subclass object.  Just take a look at the existing Engine subclasses in engines.js and you'll see how to add a new one pretty easily.
Make sure to add the name of your new engine to EXPORTED_SYMBOLS at the top of engines.js.

To weave/modules/stores.js, you'll need to add a new subclass of Store.  (Your Engine subclass will instantiate your Store subclass as a member.)  Make sure to add your new subclass to EXPORTED_SYMBOLS.

Your Store subclass can store the user data however you see fit, as long as it provides the right interface.  You need to implement the following methods:

wrap()
wipe()
resetGUIDs()
_createCommand( command ),
_removeCommand( command ),
_editCommand( command )

wrap() returns a JSON representation of all the data that is being stored.  The top-level structure of the JSON is a dictionary, where each value is a representation of one object form the user data store, and the key for that value is a GUID.

wipe() should remove and delete all data from the local store, and return nothing.

resetGUIDs() is called in the case where the GUIDs of the local store have gotten out of sync with the GUIDs on the server, so that there's some kind of GUID conflict.  See the implementation of BookmarkStore.resetGUIDs() for an example of how this should work.

_createCommand, _removeCommand, and _editCommand methods are called by the synchronization algorithm, in order to update the contents of your store.  The argument passed to each one is a command object describing what user data should be created in the store, removed from the store, or updated within the store, respectively.

the command object which gets passed into these has a .GUID property, which uniquely identifies which item in the store is to be affected.  command.GUID will correspond to the GUID keys of the JSON dictionary that your returns from wrap().  The command object additionally has a .data property which, in the case of _createCommand() and _editCommand(), contains the new data to be applied to the store.


In weave/modules/syncCores.js, you'll need to create a subclass of SyncCore (and add it to EXPORTED_SYMBOLS).  Your Engine subclass will instantiate and use your SyncCore subclass.

It needs to implement these methods:

_itemExists( GUID )
_commandLike( a, b )

_itemExists should return True if a data object of the given GUID exists on the system (i.e. in the corresponding Store), False otherwise.

_commandLike is passed two command objects as arguments.  It should return True if the two commands are determined to refer to the same thing.  This is meant to eliminate duplicate or redundant commands.  See the implementation of BookmarkSyncCore._commandLike() for inspiration.

Once you've created an engine, syncCore, and store, you'll need to make sure that your Engine is instantiated and registered in services.js, in the function WeaveSvc().  Look for where the existing engines are registered (to Engines.register) and add yours.

The last thing is to add your new data type to the Weave preferences UI.  Look in weave/chrome/content/preferences.xul for the boolean preferences called extensions.weave.bookmarks, extensions.weave.history, etc.  They're boolean preferences because they're checkboxes which turn synchronization of a given datatype on or off.  Add one for your datatype using the existing XUL tags as a model.

The text labels for the checkboxes in the preferences GUI are defined in a separate file to make internationalization easier.  The file for US English is weave/chrome/local/en-US/preferences.dtd.  Create an entity here with a name corresponding to what you used in preferences.xul, and with an appropriate value for the label string.

Finally, set the default value of your preference in defaults/preferences/sync.js.
